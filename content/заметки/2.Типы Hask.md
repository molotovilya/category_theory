## Почему именно типы?

В функциональном программировании существует подход, где типы языка рассматриваются как объекты категории. Но почему именно типы, а не, скажем, конкретные значения?

Ответ связан с желанием сохранить абстракцию. Когда мы работаем с конкретными значениями, мы не хотим лезть внутрь структуры объектов, разбираться в их внутреннем устройстве. Типы прекрасно подходят для этой цели, потому что для каждого из них уже предопределены способы оперирования как с чем-то целым.

Возьмём простой пример: мы работаем с числом 5 точно так же, как с числом 125. Нам не нужно продумывать, как это работает низкоуровнево — на уровне битов, представления в памяти и так далее. Мы просто знаем, что это числа, и с ними можно делать определённые операции.

## Функции как морфизмы

Между объектами-типами существуют функции-морфизмы. Например, функция `length`, которая идёт от типа `String` к типу `Int` и вычисляет число символов в строке. Это классический морфизм — стрелка между двумя объектами категории.

Но вот что интересно: саму эту функцию мы тоже можем рассматривать как элемент другого объекта! Это тесно связано с понятием экспоненциала в категориях. Функции сами становятся объектами первого класса, с которыми можно работать.

## Конструирование сложных типов

Мы можем вводить более сложные объекты, и прекрасный пример этого — тип `List`. Из простых чисел, строк или символов мы конструируем более сложные обёртки — списки. `List[Int]`, `List[String]` и так далее.

Это же применяется при работе со специфическими типами вроде `Option`, `Either`, `Future`, `Maybe` — которые строятся с помощью функторов. Причём категория отображается сама в себя, работая согласованно и на простых, и на сложных типах. Если у нас есть функция от `Int` к `String`, мы можем "поднять" её до функции от `List[Int]` к `List[String]`.

## Категория Hask — модель, а не строгая математика

Однако есть важное замечание, которое нельзя игнорировать. Эту модель, которую называют категорией Hask (от Haskell), следует воспринимать не как строго-математическую категорию, а именно как модель.

Причина этого — наличие неопределённого поведения функций или бесконечных зацикливаний. В реальном программировании мы не всегда можем однозначно сказать, каким будет вычисление, как в чистой математике. Иногда мы получаем ошибку, иногда программа зависает.

Рекурсивные функции могут не дать однозначного результата или зациклиться навсегда. Побочные эффекты — вроде записи в файл или отправки данных по сети — нарушают чистоту морфизмов. С этим, конечно, есть способы бороться (например, монады вроде `IO` для инкапсуляции эффектов), но всё это ломает идеализм категорной абстракции.

## Практическая ценность

И всё же, несмотря на эти ограничения, категория Hask остаётся неплохой моделью. Она работает в большинстве случаев и помогает применять глубокие математические идеи в практическом программировании. Это мост между абстрактной математикой и реальным кодом, который мы пишем каждый день.

---

**Связанные заметки:**

- [[функциональное программирование]]
- [[функторы]]
- [[монады]]
- [[теория типов]]
- [[экспоненциал]]